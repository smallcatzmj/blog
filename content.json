{"meta":{"title":"smallcatzmj","subtitle":null,"description":null,"author":"ScZmj","url":"smallcatzmj.github.io/blog","root":"/blog/"},"pages":[{"title":"about","date":"2019-05-17T16:26:55.000Z","updated":"2019-05-17T16:27:17.629Z","comments":true,"path":"about/index.html","permalink":"smallcatzmj.github.io/blog/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2019-05-17T16:26:05.000Z","updated":"2019-05-17T16:26:40.397Z","comments":false,"path":"categories/index.html","permalink":"smallcatzmj.github.io/blog/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2019-05-17T16:24:24.000Z","updated":"2019-05-17T16:25:50.901Z","comments":false,"path":"tags/index.html","permalink":"smallcatzmj.github.io/blog/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"我爱学算法","slug":"算法系列1","date":"2019-12-24T16:00:00.000Z","updated":"2019-12-27T13:37:06.236Z","comments":true,"path":"2019/12/25/算法系列1/","link":"","permalink":"smallcatzmj.github.io/blog/2019/12/25/算法系列1/","excerpt":"天气之子","text":"天气之子 1.时间复杂度数据规模：1second之内解决问题： O(n^2)的算法可以处理大约10^4级别的数据 O(n)的算法可以处理大约10^8级别的数据 O(nlogn)的算法可以处理大约10^7级别的数据 因为从1一直加到10^8计算机的运行时间大约为0.4s,在1s以内。 O所表示的是代码执行的平均代码量的上界，前面通常会有一个常数，例如cO(2^n)，有的时候也指平均值。 O(logn)表示n经过几次除以一个常数的操作后，等于0 或者1等常数，如log10n = O(logn),n一直除以10直到变为1. 二分查找 log2n = O(logn) 可由数学式推导：logaN = logab * logbN，logab为一个常数。 特殊情况：时间复杂度O(sqrt(n))，素数的判断： 1234567boolean isPrime(int n){ for (int x = 2 ;x*x = 1 and b > 1 是常量，其表示的意义是n表示问题的规模，a表示递归的次数也就是生成的子问题数，b表示每次递归是原来的1/b之一个规模，f（n）表示分解和合并所要花费的时间之和。 解法：①当dlogb a时，时间复杂度为O(n^d) 2.数组中的问题①二分查找1234567891011121314151617181920/** * * @param arr 有序数组 * @param n 数组长度 * @param target 目标值 * @return 目标值的数组下标 */static int binarysearch(int arr[], int n,int target){ int l = 0; int r = n - 1; //在[l...r]之间寻找目标值 while (l = 0 && p2 >= 0){//遍历比较两个数组的值，直到一个数组遍历完 if (nums1[p1] >= nums2[p2]){ nums1[p] = nums1[p1]; p -- ; p1 --; }else { nums1[p] = nums2[p2]; p -- ; p2 --; } }while (p2 >= 0)//数组1优先遍历完，将数组2中的剩余值传入数组1 nums1[p--] = nums2[p2--];} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法","slug":"算法","permalink":"smallcatzmj.github.io/blog/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"smallcatzmj.github.io/blog/tags/算法/"},{"name":"数组","slug":"数组","permalink":"smallcatzmj.github.io/blog/tags/数组/"}]},{"title":"排序算法总结","slug":"数据结构","date":"2019-12-24T16:00:00.000Z","updated":"2019-12-27T13:36:09.649Z","comments":true,"path":"2019/12/25/数据结构/","link":"","permalink":"smallcatzmj.github.io/blog/2019/12/25/数据结构/","excerpt":"我想吃掉你的胰脏","text":"我想吃掉你的胰脏 ①冒泡排序123456789101112public static void bubbleSort(int[] arr){ //数组为空或只有一个元素，结束 if (arr == null || arr.length 0;end--){ for (int i = 0; i < end; i++) { if (arr[i] > arr[i + 1]) swap(arr,i,i+1); } }} ​ 时间复杂度O(n²),空间复杂度O(1) ②选择排序12345678910111213141516public static void selectSort(int[] arr){ //数组为空或只有一个元素，结束 if (arr == null || arr.length arr[j + 1]; j--) { swap(arr,j,j + 1); } }} ​ 时间复杂度O(n²),空间复杂度O(1) ④归并排序12345678910111213141516171819202122232425262728293031public static void mergeSort(int[] arr){ //数组中的元素数量小于等于1，直接返回 if (arr == null || arr.length { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"数据结构","slug":"数据结构","permalink":"smallcatzmj.github.io/blog/categories/数据结构/"}],"tags":[{"name":"算法","slug":"算法","permalink":"smallcatzmj.github.io/blog/tags/算法/"},{"name":"排序","slug":"排序","permalink":"smallcatzmj.github.io/blog/tags/排序/"}]}]}